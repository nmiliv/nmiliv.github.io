// first-pass JS code generated by prompting ChatGPT to translate original Python code
// result: It... renders something. Not the right thing though. The numerical methods
// and gas dynamics sections seem to have translated correctly, but the actual nozzle
// design portion failed. Not entirely surprising considering that the original
// code structure was a hot mess lol. Still, it's a pretty good starting point.

const canvas = document.getElementById("plot");
const ctx = canvas.getContext("2d");

const deg = Math.PI / 180;

// ---------- Numerical Methods ----------

function bisect(low, high, tol, maxn, f) {
  let mid;
  for (let i = 0; i < maxn; i++) {
    mid = 0.5 * (low + high);
    if (Math.abs(high - low) / 2 < tol) break;
    if (f(mid) * f(low) > 0) low = mid;
    else high = mid;
  }
  return mid;
}

function secant(p0, p1, tol, maxn, f) {
  let p = p1;
  for (let i = 0; i < maxn; i++) {
    const q0 = f(p0), q1 = f(p1);
    const pn = p1 - q1 * (p1 - p0) / (q1 - q0);
    if (Math.abs(pn - p) < tol) break;
    p0 = p1;
    p1 = pn;
    p = pn;
  }
  return p;
}

function combiBiSecant(low, high, crossover, tol, maxn, f) {
  const rough = bisect(low, high, crossover, maxn, f);
  return secant(rough - crossover / 2, rough + crossover / 2, tol, maxn, f);
}

// ---------- Gas Dynamics ----------

function findNu(M, g) {
  return Math.sqrt((g + 1) / (g - 1)) *
         Math.atan(Math.sqrt((g - 1) / (g + 1) * (M * M - 1))) -
         Math.atan(Math.sqrt(M * M - 1));
}

function findPMM(nu, g) {
  return combiBiSecant(1, 100, 3, 1e-8, 30, m => findNu(m, g) - nu);
}

function findMu(M) {
  return Math.asin(1 / M);
}

// ---------- Geometry ----------

function intersect(x1, y1, phi1, x2, y2, phi2) {
  const dx = x2 - x1;
  const dy = y1 - y2;
  const d1 = (dy + dx * Math.tan(phi2)) / (Math.tan(phi1) + Math.tan(phi2));
  return [
    x1 + d1,
    y1 - d1 * Math.tan(phi1)
  ];
}

// ---------- MoC Nozzle ----------
function designNozzle(desMach, theta0, lines, gamma) {
    let thetamax = findNu(desMach, gamma)/2; // calculate initial wall expansion angle
    let dtheta = (thetamax - theta0)/(lines - 1); // find spacing between initial characteristics
    // TODO currently the characteristics are linearly spaced by theta, but it might be nicer to try linearly spacing them by mu
    let nodes = []; // point number, kmin, kmax, theta, nu, mach, mu
    // big array that holds all the flow properties of the grid points
    // this thing gets... a little messy

    let theta = theta0+dtheta*0
    let nu = theta0 + dtheta*0
    let kmin = theta + nu
    let kmax = (theta - nu)
    let mach = (findPMM(nu, gamma))
    let mu = (findMu(mach))
    let nodenum = 1;
    // loop to initialize the first set  of grid points
    // all of these points are children of the expansion corner
    for (let i = 0; i < lines; i++) {
        theta = theta0+dtheta*i; // know theta and nu for initial points
        nu = theta0 + dtheta*i;
        kmin = theta + nu; // use that to find kmin, kmax, mach, and mu
        kmax = (theta - nu);
        mach = (findPMM(nu, gamma));
        mu = (findMu(mach));
        nodes.push({nodenum, kmin, kmax, theta, nu, mach, mu}); // put the valus in our big list
        nodenum += 1
    }
    nodes.push({nodenum, kmin, kmax, theta, nu, mach, mu}); // wall points are just a copy of the last point we added
    nodenum += 1;

    // this is the part where keeping track of which node we're on gets a little messy
    // while linesrem > 1: // the big loop cycle which characteristic line we're on
    for(let linesrem = lines - 1; linesrem >= 1; linesrem-=1){
        // linesrem -= 1 // first we start with the point on the centerline
        theta = 0; // perfect reflection across centerline, can assume theta = 0
        nu = nodes.at(-1-linesrem)['kmin']; // take the last point that is above the centerline, both parents have opposite nu so inherit that value
        kmin = theta + nu; // find kmin, kmax, etc.
        kmax = theta - nu;
        mach = findPMM(nu, gamma);
        mu = findMu(mach);
        let indexCenterAnchor = nodes.length; // also it's nice to remember the position of the centerline point for this line
        nodes.push({nodenum, kmin, kmax, theta, nu, mach, mu});
        nodenum += 1;
        for(let i = 0; i < linesrem - 1; i++){
        // for i in range(linesrem - 1): // This loop calculates all the point between the centerline and the wall
            kmin = nodes.at(-1-linesrem)['kmin']; // inherit kmin and kmax from parents
            kmax = nodes[indexCenterAnchor]['kmax']; // this is the part where list index arithmatic gets hard
            theta = 0.5*(kmin + kmax); // find theta, nu, etc from kmin and kmax
            nu = 0.5*(kmin - kmax);
            mach = findPMM(nu, gamma);
            mu = findMu(mach);
            nodes.push({nodenum, kmin, kmax, theta, nu, mach, mu});
            nodenum += 1;
        }
        nodes.push({nodenum, kmin, kmax, theta, nu, mach, mu}); // wall point is copy of last internal point (since no reflection off wall)
        nodenum += 1;
    }

    // start finding cartesian positions of all the points
    let points = [[0],[1]]; // throat is located at (0, 1)

    // find position of first point (centerline), this is just the mu angle of the characteristic
    let y3 = 0;
    let x3 = (points[1][0]-y3) / Math.tan(nodes[0]['mu'] - nodes[0]['theta']); // TODO perhaps make this more readable
    points[0].push(x3);
    points[1].push(y3);

    // find remaining position of first set of points (where parent is throat expansion corner)
    for(let i = 0; i < lines-1; i++){
    // for i in range(lines-1):
        const x1 = points[0][0]
        const y1 = points[1][0]
        const x2 = points[0].at(-1)
        const y2 = points[1].at(-1)
        const phi1 = nodes[i+1]['mu'] - nodes[i+1]['theta'] // look at theta and mu to find mach lines (intersections are grid point locations)
        const phi2 = (nodes[i+1]['mu'] + nodes[i+1]['theta'] + nodes[i]['mu'])/2 // geometry!
        let arr = intersect(x1, y1, phi1, x2, y2, phi2)
        x3 = arr[0];
        y3 = arr[1];
        points[0].push(x3)
        points[1].push(y3) // add coordinates to list
    }
    let wallslope = (thetamax + nodes[lines]['theta'])/2; // find wall point from average slope of wall and characteristic
    let x1 = points[0][0];
    let y1 = points[1][0];
    let x2 = points[0].at(-1);
    let y2 = points[1].at(-1);
    let phi1 = -wallslope;
    let phi2 = nodes[lines]['mu'] + nodes[lines]['theta'];
    let arr = intersect(x1, y1, phi1, x2, y2, phi2);
    x3 = arr[0];
    y3 = arr[1];
    points[0].push(x3);
    points[1].push(y3);

    // big loop that handles all the points after the initial line
    // linesrem = lines - 1;
    // while linesrem > 0:
    for(let linesrem = lines-1; linesrem > 0; linesrem-=1){
        const index = points[0].length;
        const prevcenter = index - linesrem - 2; // keep track of what the centerline point on the previous line is
        y3 = 0; // add the point on the current line's centerline point
        x3 = (points[1][prevcenter+1]-y3) / Math.tan(nodes[prevcenter]['mu']) + points[0][prevcenter+1];
        let currNode = points[0].length; // also keep track of what the current centerline is
        // use1 = nodes[prevcenter][0] // debug stuff
        // print("calculating {:} using {:}".format(currNode, use1))
        points[0].push(x3);
        points[1].push(y3);
        // find remaining internal points
        for(let i = 0; i < linesrem - 1; i++){
        // for i in range(linesrem-1):
            const prevupper = index + i - linesrem - 1;
            const prevlower = index + i - 1;
            // so... keeping track of which points we're referencing is getting harder
            // prevupper and prevlower keep track of the parents of the current node
            x1 = points[0][prevupper+1];
            y1 = points[1][prevupper+1];
            x2 = points[0].at(-1);
            y2 = points[1].at(-1);
            phi1 = (nodes[prevupper]['mu'] - nodes[prevupper]['theta'] + nodes[index+i+1]['mu'] - nodes[index+i+1]['theta'])/2;
            phi2 = (nodes[prevlower]['mu'] + nodes[prevlower]['theta'] + nodes[index+i+1]['mu'] + nodes[index+i+1]['theta'])/2;
            const arr = intersect(x1, y1, phi1, x2, y2, phi2);
            x3 = arr[0];
            y3 = arr[1];
            currNode = points[0].length;
            // use1 = nodes[prevupper][0]
            // use2 = nodes[prevlower][0]
            // print("calculating {:} using {:}, {:}".format(currNode, use1, use2))
            points[0].push(x3);
            points[1].push(y3);
        }
        // and then find the wall point using average theta between the current and previous points
        wallslope = (nodes[index - 2]['theta'] + nodes[index + linesrem - 1]['theta'])/2;
        x1 = points[0][index - 1];
        y1 = points[1][index - 1];
        x2 = points[0].at(-1);
        y2 = points[1].at(-1);
        phi1 = -wallslope;
        phi2 = nodes[index + linesrem - 2]['mu'] + nodes[index + linesrem - 2]['theta'];
        const arr = intersect(x1, y1, phi1, x2, y2, phi2);
        x3 = arr[0];
        y3 = arr[1];
        points[0].push(x3);
        points[1].push(y3);
    }
    return [points, nodes];
}

// ---------- Drawing ----------

function draw(points, lines, nodes, gamma) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  const scale = Math.min(80, (document.getElementById('plot').clientWidth-200)/Math.max(...points[0]));
  const ox = 100;
  const oy = canvas.height/2;

  // ctx.beginPath();
  // for (let i = 0; i < points[0].length; i++) {
  //   const x = ox + points[0][i] * scale;
  //   const y = oy - points[1][i] * scale;
  //   if (i === 0) ctx.moveTo(x, y);
  //   else ctx.lineTo(x, y);
  // }
  // ctx.stroke();
  ctx.strokeStyle = "gray";
  ctx.lineWidth = 1;
  ctx.beginPath();
  let centernodes = [] // will be keeping track of list of center nodes
  let lastend = 0
  let edgex = [points[0][0]]
  let edgey = [points[1][0]] // add throat to edge points list
  for(let i=0; i<lines; i++){
      // loop through characetristic lines
      let xvals = []
      let yvals = []
      xvals.push(points[0][0])
      yvals.push(points[1][0])
      for(let j=0; j < lines+1; j++){
          // and then loop through points on charactersitic lines
          // start by traversing across previous lines
          if(j < i){
              xvals.push(points[0][centernodes[j]+i-j])
              yvals.push(points[1][centernodes[j]+i-j])
          } else if(j == i){
              // then add the centerline point
              centernodes.push(lastend + 1)
              xvals.push(points[0][centernodes.at(-1)])
              yvals.push(points[1][centernodes.at(-1)])
          } else {
              // and lastly add all the points downstream of the centerline
              // print("{:}, {:} ".format(i, j) + str(centernodes))
              xvals.push(points[0][centernodes.at(-1)+j-i])
              yvals.push(points[1][centernodes.at(-1)+j-i])
          }
      }
      lastend = centernodes.at(-1) + lines - i
      // if plots enabled, add the lines to the plot as well
      // if axs != None:
      //     axs.plot(xvals, yvals)

      for(let i = 0; i < xvals.length; i++){
        const x = ox + xvals[i] * scale;
        const y = oy - yvals[i] * scale;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      for(let i = 0; i < xvals.length; i++){
        const x = ox + xvals[i] * scale;
        const y = oy + yvals[i] * scale;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }

      // the last point is also an edge, keep track of that
      edgex.push(points[0][lastend])
      edgey.push(points[1][lastend])
  }
  ctx.stroke();
  ctx.strokeStyle = "black";
  ctx.lineWidth = 5;
  ctx.beginPath();
  for(let i = 0; i < edgex.length; i++){
      const x = ox + edgex[i] * scale;
      const y = oy - edgey[i] * scale;
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
  }
  for(let i = 0; i < edgex.length; i++){
      const x = ox + edgex[i] * scale;
      const y = oy + edgey[i] * scale;
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
  }
  ctx.stroke();
  var divthingy = document.getElementById("points");
  divthingy.innerHTML = "x\ty<br>";
  divthingy.innerHTML += "------\t------<br>";
  for(let i = 0; i < edgex.length; i++){
    divthingy.innerHTML+= edgex[i].toFixed(4) + "\t" + edgey[i].toFixed(4) + "<br>";
  }
  divthingy = document.getElementById("verbose");
  divthingy.innerHTML = "x\ty\ttheta\tmach\tmu\tnu\tkmin\tkmax<br>";
  divthingy.innerHTML += "------\t------\t------\t------\t------\t------\t------\t------<br>";
  // divthingy.innerHTML += "------\t------<br>";
  nodes.unshift({nodenum:0, theta:0, mach:1, mu:findMu(1), nu:findNu(1, gamma), kmin:NaN, kmax:NaN})
  for(let i = 0; i < points[0].length; i++){
    divthingy.innerHTML+= points[0][i].toFixed(4) + "\t" + points[1][i].toFixed(4) + "\t" + nodes[i].theta.toFixed(4) + "\t" + nodes[i].mach.toFixed(4) + "\t" + nodes[i].mu.toFixed(4) + "\t" + nodes[i].nu.toFixed(4) + "\t" + nodes[i].kmin.toFixed(4) + "\t" + nodes[i].kmax.toFixed(4) + "<br>";
  }
}

// ---------- UI ----------

function update() {
  const gamma = +gammaInput.value;
  const mach = +machInput.value;
  const lines = +linesInput.value;
  const theta0 = +theta0Input.value * deg;
  const ans = designNozzle(mach, theta0, lines, gamma);
  const points = ans[0];
  const nodes = ans[1]
  draw(points, lines, nodes, gamma);

}

function updateBox() {
  gammaInput.value = gammaInputBox.value;
  machInput.value = machInputBox.value;
  linesInput.value = linesInputBox.value;
  theta0Input.value = theta0InputBox.value;

  update();
}

function updateSlider() {
  gammaInputBox.value = gammaInput.value;
  machInputBox.value = machInput.value;
  linesInputBox.value = linesInput.value;
  theta0InputBox.value = theta0Input.value;

  update();
}

function reset() {
  gammaInput.value = 1.4;
  machInput.value = 2.4;
  linesInput.value = 7;
  theta0Input.value = 0.375;
  gammaInputBox.value = gammaInput.value;
  machInputBox.value = machInput.value;
  linesInputBox.value = linesInput.value;
  theta0InputBox.value = theta0Input.value;
  update();
}

// Bind inputs
const gammaInput = document.getElementById("gamma");
const machInput = document.getElementById("mach");
const linesInput = document.getElementById("lines");
const theta0Input = document.getElementById("theta0");

[gammaInput, machInput, linesInput, theta0Input]
  .forEach(e => e.addEventListener("input", updateSlider));

const gammaInputBox = document.getElementById("gammaBox");
const machInputBox = document.getElementById("machBox");
const linesInputBox = document.getElementById("linesBox");
const theta0InputBox = document.getElementById("theta0Box");

[gammaInputBox, machInputBox, linesInputBox, theta0InputBox]
  .forEach(e => e.addEventListener("input", updateBox));

const resetInput = document.getElementById("reset");
resetInput.addEventListener("click", reset)

update();
